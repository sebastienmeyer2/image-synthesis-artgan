<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.project API documentation</title>
<meta name="description" content="Evaluate ArtGAN on different epochs â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.project</code></h1>
</header>
<section id="section-intro">
<p>Evaluate ArtGAN on different epochs.</p>
<p>The purpose of this file is to implement functions
using trained models and utility functions in order
to create visualizations of the process at different
steps</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Evaluate ArtGAN on different epochs.

The purpose of this file is to implement functions
using trained models and utility functions in order
to create visualizations of the process at different
steps
&#34;&#34;&#34;


# Importing Python packages
import os
from typing import List
import argparse
import json
import torch
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
font = {&#34;size&#34;: 18}
mpl.rc(&#34;font&#34;, **font)
from mpl_toolkits.axes_grid1 import ImageGrid

# Importing our own files and classes
from gan.artgan import ArtGAN
import utils


def artgan_evolution(starting_epoch: int, ending_epoch: int, step_epoch: int,
                     device: torch.device, use_cuda: bool,
                     data_type:str, version: str, data_classes: List,
                     start_channels: int = 110, img_size: int = 64,
                     input_channels: int = 3, nb_classes: int = 10,
                     alpha: float = 0.2) -&gt; None:
    &#34;&#34;&#34;Plot the evolution of the ArtGAN.

    Images are generated from same initial noise for
    every model saved during the chosen epochs.

    Args:
        starting_epoch: first epoch to generate image
        ending_epoch: last epoch to generate image
        step_epoch: step between each model in number of
            epochs
        device: the device to use everywhere
        use_cuda: whether we are using CUDA globally
        data_type: the name of the dataset
        version: the version of the GANs
        data_classes: a list containing the name of the classes
        start_channels: the number of channels for the
            Generator part
        img_size: the size of the input images, expected to
            be squared images
        input_channels: the number of channels in the input
            images
        nb_classes: the number of classes in the dataset,
            except FAKE class e.g. 10 for CIFAR-10
        alpha: the negative slope for LeakyReLU activation
    &#34;&#34;&#34;
    Z_hat, Yk_hat = utils.fake_noise_all_classes(start_channels, nb_classes, device)
    img_labels = torch.argmax(Yk_hat, dim=1)
    Z_Yk_hat = torch.cat([Z_hat, Yk_hat], dim=1)

    nb_models = 1+(ending_epoch-starting_epoch)//step_epoch

    T = list(range(starting_epoch, ending_epoch+1, step_epoch))

    generated_imgs = []

    for i in range(nb_models):

        step_artgan = ArtGAN(data_type, version, img_size, nb_classes,
                             input_channels=input_channels, start_channels=start_channels,
                             alpha=alpha, retrain_epoch=T[i], device=device)

        if use_cuda:
            step_artgan.cuda()
        step_artgan.eval()

        model_imgs = step_artgan.G(Z_Yk_hat)
        model_imgs = model_imgs.cpu().detach().numpy()
        model_imgs = np.transpose(model_imgs, (0, 2, 3, 1))
        generated_imgs.append(model_imgs)

    for j in range(nb_classes):

        print(&#34;\r\033[KSaving {}...&#34;.format(data_classes[img_labels[j]]), end=&#34;&#34;, flush=True)

        nrows = 1+nb_models//5
        ncols = 4
        fig = plt.figure(figsize=(4*ncols, 4*nrows))
        grid = ImageGrid(fig, 111, nrows_ncols=(nrows, ncols), axes_pad=(0.05, 0.33))

        row = 0
        col = 0
        for ax, i in zip(grid, range(nb_models)):

            ax.imshow(generated_imgs[i][j])
            ax.set_title(&#34;Epoch {}&#34;.format(T[i]))
            ax.axis(&#34;off&#34;)

            col += 1
            if T[i]%4 == 0:
                row += 1
                col = 0

        # fig.suptitle(&#34;Generation of {} at different epochs&#34;.format(data_classes[img_labels[j]]))

        eval_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/evol/&#34;
        if not os.path.exists(eval_folder):
            os.makedirs(eval_folder)
        path_to_file = eval_folder + &#34;evolution_{}.png&#34;.format(data_classes[img_labels[j]])
        plt.tight_layout()
        plt.savefig(path_to_file)
        plt.close()

    print(&#34;Done.&#34;)

def save_loss(data_type:str, version: str) -&gt; None:
    &#34;&#34;&#34;Save the loss evolution for the given ArtGAN.

    Args:
        data_type: the input dataset
        version: the version of the GAN
    &#34;&#34;&#34;
    loss_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/losses/&#34;
    path_to_loss = loss_folder + &#34;loss.csv&#34;

    loss_data = pd.read_csv(path_to_loss)

    T = loss_data[&#34;Epoch&#34;]
    G_loss = loss_data[&#34;G_loss&#34;]
    D_loss = loss_data[&#34;D_loss&#34;]

    plt.plot(T, G_loss, label=&#34;Generator loss&#34;)
    plt.plot(T, D_loss, label=&#34;Discriminator loss&#34;)
    plt.legend()
    plt.xlabel(&#34;Epoch&#34;)
    plt.ylabel(&#34;Loss&#34;)
    # plt.title(&#34;Loss of {} version on {} dataset&#34;.format(version, data_type))

    path_to_file = loss_folder + &#34;loss.jpg&#34;
    plt.tight_layout()
    plt.savefig(path_to_file)
    plt.close()

def save_score(data_type:str, version: str) -&gt; None:
    &#34;&#34;&#34;Save the score evolution for the given ArtGAN.

    Args:
        data_type: the input dataset
        version: the version of the GAN
    &#34;&#34;&#34;
    score_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/scores/&#34;
    path_to_score = score_folder + &#34;score.csv&#34;

    score_data = pd.read_csv(path_to_score)

    T = score_data[&#34;Epoch&#34;]
    D_score = score_data[&#34;Score&#34;]

    plt.plot(T, D_score, label=&#34;True Negatives&#34;)
    plt.legend()
    plt.xlabel(&#34;Epoch&#34;)
    plt.ylabel(&#34;Specificity (in %)&#34;)
    # plt.title(&#34;Score of {} version on {} dataset&#34;.format(version, data_type))

    path_to_file = score_folder + &#34;score.jpg&#34;
    plt.tight_layout()
    plt.savefig(path_to_file)
    plt.close()

def save_both(data_type:str, version: str) -&gt; None:
    &#34;&#34;&#34;Save loss and score evolution for the given ArtGAN.

    Args:
        data_type: the input dataset
        version: the version of the GAN
    &#34;&#34;&#34;
    # Score data
    score_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/scores/&#34;
    path_to_score = score_folder + &#34;score.csv&#34;

    score_data = pd.read_csv(path_to_score)

    T = score_data[&#34;Epoch&#34;]
    D_score = score_data[&#34;Score&#34;]

    # Loss data
    loss_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/losses/&#34;
    path_to_loss = loss_folder + &#34;loss.csv&#34;

    loss_data = pd.read_csv(path_to_loss)

    T = loss_data[&#34;Epoch&#34;]
    G_loss = loss_data[&#34;G_loss&#34;]
    D_loss = loss_data[&#34;D_loss&#34;]

    # Plotting both
    fig, ax1 = plt.subplots()

    ax1.set_xlabel(&#34;Epoch&#34;)
    ax1.set_ylabel(&#34;Loss&#34;)
    ax1.plot(T, G_loss, label=&#34;Generator loss&#34;, color=&#34;blue&#34;)
    ax1.plot(T, D_loss, label=&#34;Discriminator loss&#34;, color=&#34;red&#34;)
    ax1.tick_params(axis=&#34;y&#34;)
    # ax1.legend(loc=0)

    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

    ax2.set_ylabel(&#34;Score&#34;)
    ax2.plot(T, D_score, label=&#34;True Negatives&#34;, color=&#34;green&#34;)
    ax2.tick_params(axis=&#34;y&#34;)

    both_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/both/&#34;
    if not os.path.exists(both_folder):
        os.makedirs(both_folder)

    path_to_file = both_folder + &#34;loss_score.jpg&#34;
    # plt.legend()
    plt.tight_layout()
    plt.savefig(path_to_file)
    plt.close()


if __name__ == &#34;__main__&#34;:

    # Command lines
    parser = argparse.ArgumentParser(description=&#34;A file to evaluate your GANs!&#34;)
    available_datasets = [&#34;cifar&#34;, &#34;artist&#34;, &#34;genre&#34;, &#34;style&#34;]
    parser.add_argument(&#34;data_type&#34;, type=str, choices=available_datasets, help=&#34;Please choose a dataset from those supported.&#34;)
    parser.add_argument(&#34;version&#34;, type=str, help=&#34;Please choose the version of your GAN.&#34;)

    # Sub command lines for mode
    subparsers = parser.add_subparsers(dest=&#34;subcommands&#34;, description=&#34;Please choose a mode of evaluation.&#34;)
    parser_evol = subparsers.add_parser(&#34;evolution&#34;)
    parser_evol.add_argument(&#34;start&#34;, type=int, help=&#34;Please choose the epoch to start from.&#34;)
    parser_evol.add_argument(&#34;stop&#34;, type=int, help=&#34;Please choose the epoch at which the program ends.&#34;)
    parser_evol.add_argument(&#34;step&#34;, type=int, help=&#34;Please choose the step between models.&#34;)

    parser_all = subparsers.add_parser(&#34;all&#34;)
    parser_all.add_argument(&#34;start&#34;, type=int, help=&#34;Please choose the epoch to start from.&#34;)
    parser_all.add_argument(&#34;stop&#34;, type=int, help=&#34;Please choose the epoch at which the program ends.&#34;)
    parser_all.add_argument(&#34;step&#34;, type=int, help=&#34;Please choose the step between models.&#34;)

    parser_score = subparsers.add_parser(&#34;score&#34;)

    parser_loss = subparsers.add_parser(&#34;loss&#34;)

    parser_both = subparsers.add_parser(&#34;both&#34;)

    # Args selecton
    args = parser.parse_args()

    data_type = args.data_type
    version = args.version
    mode = args.subcommands

    if mode == &#34;evolution&#34; or mode == &#34;all&#34;:
        starting_epoch = args.start
        ending_epoch = args.stop
        step_epoch = args.step

    # Turning on CUDA globally
    USE_CUDA = torch.cuda.is_available()
    print(&#34;Will we use CUDA? {}&#34;.format(USE_CUDA))
    DEVICE = torch.device(&#34;cuda&#34; if USE_CUDA else &#34;cpu&#34;)

    if data_type == &#34;cifar&#34;:

        with open(&#34;src/datasets/cifar.json&#34;, &#34;r&#34;) as f:
            CIFAR10_CLASSES = json.load(f)
        data_classes = CIFAR10_CLASSES

    elif data_type in {&#34;artist&#34;, &#34;genre&#34;, &#34;style&#34;}:

        with open(&#34;src/datasets/wikiart.json&#34;, &#34;r&#34;) as f:
            WIKIART_CLASSES = json.load(f)
        data_classes = WIKIART_CLASSES[data_type]

    else:

        raise ValueError(&#34;This dataset is not supported!&#34;)

    # ArtGAN parameters
    nb_classes = len(data_classes)
    start_channels = 100 + nb_classes
    img_size = 64
    input_channels = 3
    alpha = 0.2

    # Plotting evolution
    if mode == &#34;all&#34; or mode == &#34;evolution&#34;:
        artgan_evolution(starting_epoch=starting_epoch, ending_epoch=ending_epoch, step_epoch=step_epoch,
                         device=DEVICE, use_cuda=USE_CUDA,
                         data_type=data_type, version=version, data_classes=data_classes,
                         start_channels=start_channels, img_size=img_size,
                         input_channels=input_channels, nb_classes=nb_classes, alpha=alpha)

    # Plotting loss
    if mode == &#34;all&#34; or mode == &#34;loss&#34;:
        save_loss(data_type, version)

    # Plotting score
    if mode == &#34;all&#34; or mode == &#34;score&#34;:
        save_score(data_type, version)

    # Plotting both score &amp; loss
    if mode == &#34;all&#34; or mode == &#34;both&#34;:
        save_both(data_type, version)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.project.artgan_evolution"><code class="name flex">
<span>def <span class="ident">artgan_evolution</span></span>(<span>starting_epoch:Â int, ending_epoch:Â int, step_epoch:Â int, device:Â torch.device, use_cuda:Â bool, data_type:Â str, version:Â str, data_classes:Â List, start_channels:Â intÂ =Â 110, img_size:Â intÂ =Â 64, input_channels:Â intÂ =Â 3, nb_classes:Â intÂ =Â 10, alpha:Â floatÂ =Â 0.2) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the evolution of the ArtGAN.</p>
<p>Images are generated from same initial noise for
every model saved during the chosen epochs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starting_epoch</code></strong></dt>
<dd>first epoch to generate image</dd>
<dt><strong><code>ending_epoch</code></strong></dt>
<dd>last epoch to generate image</dd>
<dt><strong><code>step_epoch</code></strong></dt>
<dd>step between each model in number of
epochs</dd>
<dt><strong><code>device</code></strong></dt>
<dd>the device to use everywhere</dd>
<dt><strong><code>use_cuda</code></strong></dt>
<dd>whether we are using CUDA globally</dd>
<dt><strong><code>data_type</code></strong></dt>
<dd>the name of the dataset</dd>
<dt><strong><code>version</code></strong></dt>
<dd>the version of the GANs</dd>
<dt><strong><code>data_classes</code></strong></dt>
<dd>a list containing the name of the classes</dd>
<dt><strong><code>start_channels</code></strong></dt>
<dd>the number of channels for the
Generator part</dd>
<dt><strong><code>img_size</code></strong></dt>
<dd>the size of the input images, expected to
be squared images</dd>
<dt><strong><code>input_channels</code></strong></dt>
<dd>the number of channels in the input
images</dd>
<dt><strong><code>nb_classes</code></strong></dt>
<dd>the number of classes in the dataset,
except FAKE class e.g. 10 for CIFAR-10</dd>
<dt><strong><code>alpha</code></strong></dt>
<dd>the negative slope for LeakyReLU activation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def artgan_evolution(starting_epoch: int, ending_epoch: int, step_epoch: int,
                     device: torch.device, use_cuda: bool,
                     data_type:str, version: str, data_classes: List,
                     start_channels: int = 110, img_size: int = 64,
                     input_channels: int = 3, nb_classes: int = 10,
                     alpha: float = 0.2) -&gt; None:
    &#34;&#34;&#34;Plot the evolution of the ArtGAN.

    Images are generated from same initial noise for
    every model saved during the chosen epochs.

    Args:
        starting_epoch: first epoch to generate image
        ending_epoch: last epoch to generate image
        step_epoch: step between each model in number of
            epochs
        device: the device to use everywhere
        use_cuda: whether we are using CUDA globally
        data_type: the name of the dataset
        version: the version of the GANs
        data_classes: a list containing the name of the classes
        start_channels: the number of channels for the
            Generator part
        img_size: the size of the input images, expected to
            be squared images
        input_channels: the number of channels in the input
            images
        nb_classes: the number of classes in the dataset,
            except FAKE class e.g. 10 for CIFAR-10
        alpha: the negative slope for LeakyReLU activation
    &#34;&#34;&#34;
    Z_hat, Yk_hat = utils.fake_noise_all_classes(start_channels, nb_classes, device)
    img_labels = torch.argmax(Yk_hat, dim=1)
    Z_Yk_hat = torch.cat([Z_hat, Yk_hat], dim=1)

    nb_models = 1+(ending_epoch-starting_epoch)//step_epoch

    T = list(range(starting_epoch, ending_epoch+1, step_epoch))

    generated_imgs = []

    for i in range(nb_models):

        step_artgan = ArtGAN(data_type, version, img_size, nb_classes,
                             input_channels=input_channels, start_channels=start_channels,
                             alpha=alpha, retrain_epoch=T[i], device=device)

        if use_cuda:
            step_artgan.cuda()
        step_artgan.eval()

        model_imgs = step_artgan.G(Z_Yk_hat)
        model_imgs = model_imgs.cpu().detach().numpy()
        model_imgs = np.transpose(model_imgs, (0, 2, 3, 1))
        generated_imgs.append(model_imgs)

    for j in range(nb_classes):

        print(&#34;\r\033[KSaving {}...&#34;.format(data_classes[img_labels[j]]), end=&#34;&#34;, flush=True)

        nrows = 1+nb_models//5
        ncols = 4
        fig = plt.figure(figsize=(4*ncols, 4*nrows))
        grid = ImageGrid(fig, 111, nrows_ncols=(nrows, ncols), axes_pad=(0.05, 0.33))

        row = 0
        col = 0
        for ax, i in zip(grid, range(nb_models)):

            ax.imshow(generated_imgs[i][j])
            ax.set_title(&#34;Epoch {}&#34;.format(T[i]))
            ax.axis(&#34;off&#34;)

            col += 1
            if T[i]%4 == 0:
                row += 1
                col = 0

        # fig.suptitle(&#34;Generation of {} at different epochs&#34;.format(data_classes[img_labels[j]]))

        eval_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/evol/&#34;
        if not os.path.exists(eval_folder):
            os.makedirs(eval_folder)
        path_to_file = eval_folder + &#34;evolution_{}.png&#34;.format(data_classes[img_labels[j]])
        plt.tight_layout()
        plt.savefig(path_to_file)
        plt.close()

    print(&#34;Done.&#34;)</code></pre>
</details>
</dd>
<dt id="src.project.save_both"><code class="name flex">
<span>def <span class="ident">save_both</span></span>(<span>data_type:Â str, version:Â str) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Save loss and score evolution for the given ArtGAN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_type</code></strong></dt>
<dd>the input dataset</dd>
<dt><strong><code>version</code></strong></dt>
<dd>the version of the GAN</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_both(data_type:str, version: str) -&gt; None:
    &#34;&#34;&#34;Save loss and score evolution for the given ArtGAN.

    Args:
        data_type: the input dataset
        version: the version of the GAN
    &#34;&#34;&#34;
    # Score data
    score_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/scores/&#34;
    path_to_score = score_folder + &#34;score.csv&#34;

    score_data = pd.read_csv(path_to_score)

    T = score_data[&#34;Epoch&#34;]
    D_score = score_data[&#34;Score&#34;]

    # Loss data
    loss_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/losses/&#34;
    path_to_loss = loss_folder + &#34;loss.csv&#34;

    loss_data = pd.read_csv(path_to_loss)

    T = loss_data[&#34;Epoch&#34;]
    G_loss = loss_data[&#34;G_loss&#34;]
    D_loss = loss_data[&#34;D_loss&#34;]

    # Plotting both
    fig, ax1 = plt.subplots()

    ax1.set_xlabel(&#34;Epoch&#34;)
    ax1.set_ylabel(&#34;Loss&#34;)
    ax1.plot(T, G_loss, label=&#34;Generator loss&#34;, color=&#34;blue&#34;)
    ax1.plot(T, D_loss, label=&#34;Discriminator loss&#34;, color=&#34;red&#34;)
    ax1.tick_params(axis=&#34;y&#34;)
    # ax1.legend(loc=0)

    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

    ax2.set_ylabel(&#34;Score&#34;)
    ax2.plot(T, D_score, label=&#34;True Negatives&#34;, color=&#34;green&#34;)
    ax2.tick_params(axis=&#34;y&#34;)

    both_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/both/&#34;
    if not os.path.exists(both_folder):
        os.makedirs(both_folder)

    path_to_file = both_folder + &#34;loss_score.jpg&#34;
    # plt.legend()
    plt.tight_layout()
    plt.savefig(path_to_file)
    plt.close()</code></pre>
</details>
</dd>
<dt id="src.project.save_loss"><code class="name flex">
<span>def <span class="ident">save_loss</span></span>(<span>data_type:Â str, version:Â str) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Save the loss evolution for the given ArtGAN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_type</code></strong></dt>
<dd>the input dataset</dd>
<dt><strong><code>version</code></strong></dt>
<dd>the version of the GAN</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_loss(data_type:str, version: str) -&gt; None:
    &#34;&#34;&#34;Save the loss evolution for the given ArtGAN.

    Args:
        data_type: the input dataset
        version: the version of the GAN
    &#34;&#34;&#34;
    loss_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/losses/&#34;
    path_to_loss = loss_folder + &#34;loss.csv&#34;

    loss_data = pd.read_csv(path_to_loss)

    T = loss_data[&#34;Epoch&#34;]
    G_loss = loss_data[&#34;G_loss&#34;]
    D_loss = loss_data[&#34;D_loss&#34;]

    plt.plot(T, G_loss, label=&#34;Generator loss&#34;)
    plt.plot(T, D_loss, label=&#34;Discriminator loss&#34;)
    plt.legend()
    plt.xlabel(&#34;Epoch&#34;)
    plt.ylabel(&#34;Loss&#34;)
    # plt.title(&#34;Loss of {} version on {} dataset&#34;.format(version, data_type))

    path_to_file = loss_folder + &#34;loss.jpg&#34;
    plt.tight_layout()
    plt.savefig(path_to_file)
    plt.close()</code></pre>
</details>
</dd>
<dt id="src.project.save_score"><code class="name flex">
<span>def <span class="ident">save_score</span></span>(<span>data_type:Â str, version:Â str) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Save the score evolution for the given ArtGAN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_type</code></strong></dt>
<dd>the input dataset</dd>
<dt><strong><code>version</code></strong></dt>
<dd>the version of the GAN</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_score(data_type:str, version: str) -&gt; None:
    &#34;&#34;&#34;Save the score evolution for the given ArtGAN.

    Args:
        data_type: the input dataset
        version: the version of the GAN
    &#34;&#34;&#34;
    score_folder = &#34;results/&#34; + data_type + &#34;_&#34; + version + &#34;/scores/&#34;
    path_to_score = score_folder + &#34;score.csv&#34;

    score_data = pd.read_csv(path_to_score)

    T = score_data[&#34;Epoch&#34;]
    D_score = score_data[&#34;Score&#34;]

    plt.plot(T, D_score, label=&#34;True Negatives&#34;)
    plt.legend()
    plt.xlabel(&#34;Epoch&#34;)
    plt.ylabel(&#34;Specificity (in %)&#34;)
    # plt.title(&#34;Score of {} version on {} dataset&#34;.format(version, data_type))

    path_to_file = score_folder + &#34;score.jpg&#34;
    plt.tight_layout()
    plt.savefig(path_to_file)
    plt.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.project.artgan_evolution" href="#src.project.artgan_evolution">artgan_evolution</a></code></li>
<li><code><a title="src.project.save_both" href="#src.project.save_both">save_both</a></code></li>
<li><code><a title="src.project.save_loss" href="#src.project.save_loss">save_loss</a></code></li>
<li><code><a title="src.project.save_score" href="#src.project.save_score">save_score</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>